var cryptor = require('../util/cryptor');

/*
 * get token string form header of request which format is like
 *     'Bearer ****token****'
 */
function getToken(req) {
    var bearerToken = null,
        bearerHeader = req.headers["authorization"];

    if (typeof bearerHeader !== 'undefined') {
        var bearer = bearerHeader.split(" ");
        bearerToken = bearer[1];
    }

    return bearerToken;
}

function retrieveTokenObject(token) {
    return (token != null) ? cryptor.jwtVerify(token) : null;
}

function isIgnorePath(path) {
    var ignorePaths = ['/signin', '/signup', '/partials', '/uploads'],
        dummy = null;

    if (path === '/') {
        return true;
    }

    for (var i = 0, len = ignorePaths.length; i < len; i++) {
        dummy = ignorePaths[i];
        // equals or startWith
        if (path === dummy || path.lastIndexOf(dummy) === 0) {
            return true;
        }
    }

    return false;
}

module.exports = function (req, res, next) {
    console.error('current path: ' + req.path);

    // get request path
    var path = req.path;

    // if this path in the ignorePaths 
    if (isIgnorePath(path)) {
        console.log('this path in ignore path. It need not be authenticated.');
        next();
    } else {
        var token = getToken(req),
            tokenObj = retrieveTokenObject(token);

        console.log('token user: ' + JSON.stringify(tokenObj));

        // if this token is invalid 
        // and the user which represents by this token is invalid
        // the property 'iat' of tokenObj is generated by jsonwebtoken when it is signed.
        if (tokenObj != null && tokenObj.id && tokenObj.iat) {
            req.token = token;
            req.tokenUser = tokenObj;
            next();
        } else {
            // reject ...
            res.status(403).end();
        }
    }

};